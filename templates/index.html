<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Golf Pin Sheet App</title>

  <!-- FAVICON -->
  <link rel="icon" type="image/svg+xml" href='data:image/svg+xml,
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
    <rect width="100" height="100" fill="%230b5d1e"/>
    <ellipse cx="50" cy="60" rx="40" ry="28" fill="%231fa83d"/>
    <circle cx="50" cy="60" r="4" fill="black"/>
    <line x1="50" y1="60" x2="50" y2="20" stroke="white" stroke-width="3"/>
    <polygon points="50,20 75,28 50,36" fill="red"/>
  </svg>'>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#0b5d1e">
  <link rel="manifest" href="/manifest.json">

  <style>
    body{font-family:Arial;background:#0b5d1e;color:white;text-align:center;margin:0}
    .container{padding:20px}
    .panel{background:#0f7a28;padding:20px;border-radius:12px;margin:10px auto;width:90%;max-width:900px}
    button{padding:10px 20px;margin:5px;border:none;border-radius:8px;background:#1fa83d;color:white;cursor:pointer}
    input, select{margin:4px;padding:8px;border-radius:8px;border:none;max-width:220px}

    /* Responsive canvas wrapper */
    .canvas-wrap{width:100%; overflow-x:auto;}
    canvas{
      border:2px solid white;
      background:#1e8f35;
      touch-action:none;
      width:100%;
      max-width:600px;
      height:auto;
    }

    .small{font-size:12px;opacity:.9}
    .infoBox{
      margin-top:8px;
      padding:10px;
      border:1px solid rgba(255,255,255,.18);
      border-radius:10px;
      background:rgba(0,0,0,.08);
      text-align:left;
      display:inline-block;
      max-width:600px;
      width:100%;
    }
    .infoRow{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap}
    .badge{padding:2px 8px;border-radius:999px;background:rgba(255,255,255,.15);display:inline-block}
  </style>
</head>
<body>

<div class="container">
  <h1>â›³ Pin Sheet Generator</h1>

  <div class="panel">
    <h3>Datos</h3>
    <input id="club" placeholder="Nombre Club">
    <input id="course" placeholder="Nombre Campo">
    <input id="date" type="date">
  </div>

  <div class="panel">
    <input type="number" id="numHoles" value="1" min="1" max="18">
    <label>Hoyos por hoja:</label>
    <select id="layoutSelect">
      <option value="1">1 por hoja</option>
      <option value="3">3 por hoja</option>
      <option value="6">6 por hoja</option>
      <option value="9">9 por hoja</option>
      <option value="18">18 por hoja</option>
    </select>
    <button onclick="crearHoyos()">Crear Hoyos</button>
  </div>

  <div id="holesContainer"></div>

  <div class="panel">
    <button onclick="generarPDF()">Generar PDF</button>
    <iframe id="preview" width="100%" height="500" style="display:none"></iframe>
  </div>
</div>

<script>
  // Backend en el mismo host (Render / local)
  const API = location.origin;

  // âœ… Sistema real: 600x400 -> 60x40
  const X_MAX = 60;
  const Y_MAX = 40;

  let holes = [];
  document.getElementById("date").value = new Date().toISOString().split("T")[0];

  //////////////////////////////////////////////////////////////
  function crearHoyos(){
    const n = parseInt(document.getElementById("numHoles").value);
    const container = document.getElementById("holesContainer");
    container.innerHTML = "";
    holes = [];

    for(let i=0;i<n;i++){
      const panel = document.createElement("div");
      panel.className = "panel";

      panel.innerHTML = `
        <h3>Hoyo ${i+1}</h3>

        <button onclick="importar(${i})">Importar Imagen</button>
        <button onclick="detectarGreen(${i})">Detectar Green AutomÃ¡tico</button>
        <br><br>

        <div class="canvas-wrap">
          <canvas id="canvas${i}" width="600" height="400"></canvas>
        </div>
        <br>

        <button onclick="cerrarPoligono(${i})">Cerrar Green</button>
        <button onclick="limpiar(${i})">Limpiar</button>

        <br><br>

        <input id="vertical${i}" type="number" min="0" max="${Y_MAX}" placeholder="Vertical (0-${Y_MAX})">
        <input id="horizontal${i}" type="number" min="0" max="${X_MAX}" placeholder="Horizontal (0-${X_MAX})">

        <select id="lado${i}">
          <option value="left">Izquierda</option>
          <option value="right">Derecha</option>
        </select>

        <select id="unidad${i}" onchange="redraw(${i});computePinFromEdges(${i})">
          <option value="meters">Metros</option>
          <option value="yards">Yardas</option>
        </select>

        <div class="infoBox">
          <div class="infoRow">
            <div><span class="badge">Ancho disponible</span> <span id="widthInfo${i}" class="small">â€”</span></div>
            <div><span class="badge">Izq / Der</span> <span id="spaceInfo${i}" class="small">â€”</span></div>
          </div>
          <div class="small" style="margin-top:6px;opacity:.8">
            * Calculado en la altura vertical indicada (corte real del green).
          </div>
        </div>

        <input type="file" id="file${i}" hidden accept="image/*">
      `;

      container.appendChild(panel);
      initCanvas(i);
    }
  }

  //////////////////////////////////////////////////////////////
  function initCanvas(i){
    const canvas = document.getElementById("canvas"+i);
    const ctx = canvas.getContext("2d");

    holes[i] = {
      canvas, ctx,
      puntos: [],
      cerrado: false,
      image: null,
      imgObj: null,
      pin: null,
      baseY: null
    };

    redraw(i);

    document.getElementById("vertical"+i).addEventListener("input", ()=>{computePinFromEdges(i); redraw(i);});
    document.getElementById("horizontal"+i).addEventListener("input", ()=>{computePinFromEdges(i); redraw(i);});
    document.getElementById("lado"+i).addEventListener("change", ()=>{computePinFromEdges(i); redraw(i);});

    canvas.addEventListener("pointerdown", e=>{
      const rect = canvas.getBoundingClientRect();
      holes[i].puntos.push({
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      });
      redraw(i);
    });
  }

  //////////////////////////////////////////////////////////////
  // GRID X:0â€“60, Y:0â€“40 (similar al PDF)
  //////////////////////////////////////////////////////////////
  function drawGrid(i){
    const h = holes[i];
    const ctx = h.ctx;
    const canvas = h.canvas;

    ctx.fillStyle = "#1e8f35";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const stepX = canvas.width / X_MAX;
    const stepY = canvas.height / Y_MAX;

    // lÃ­neas cada 5 (mÃ¡s fuerte cada 10)
    for(let v=0; v<=X_MAX; v+=5){
      const x = v * stepX;
      ctx.strokeStyle = (v % 10 === 0) ? "rgba(255,255,255,0.22)" : "rgba(255,255,255,0.10)";
      ctx.lineWidth = (v % 10 === 0) ? 1.2 : 1;
      ctx.beginPath();
      ctx.moveTo(x,0);
      ctx.lineTo(x,canvas.height);
      ctx.stroke();
    }

    for(let v=0; v<=Y_MAX; v+=5){
      const y = canvas.height - (v * stepY);
      ctx.strokeStyle = (v % 10 === 0) ? "rgba(255,255,255,0.22)" : "rgba(255,255,255,0.10)";
      ctx.lineWidth = (v % 10 === 0) ? 1.2 : 1;
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(canvas.width,y);
      ctx.stroke();
    }

    // labels
    ctx.fillStyle = "rgba(255,255,255,0.65)";
    ctx.font = "10px Arial";
    for(let v=0; v<=X_MAX; v+=10){
      const x = v * stepX;
      ctx.fillText(v, x+2, 12);
    }
    for(let v=0; v<=Y_MAX; v+=10){
      const y = canvas.height - (v * stepY);
      ctx.fillText(v, 2, y-2);
    }
  }

  //////////////////////////////////////////////////////////////
  function redraw(i){
    const h = holes[i];
    const ctx = h.ctx;
    const canvas = h.canvas;

    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid(i);

    if(h.imgObj) ctx.drawImage(h.imgObj,0,0,canvas.width,canvas.height);

    // polÃ­gono
    if(h.puntos.length>0){
      ctx.strokeStyle = "white";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(h.puntos[0].x, h.puntos[0].y);
      h.puntos.forEach(p=>ctx.lineTo(p.x,p.y));
      if(h.cerrado) ctx.closePath();
      ctx.stroke();
    }

    // pin + lÃ­neas
    if(h.pin){
      // base inferior
      ctx.strokeStyle = "rgba(255,170,0,0.9)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, h.pin.baseY);
      ctx.lineTo(canvas.width, h.pin.baseY);
      ctx.stroke();

      // lÃ­nea horizontal del pin
      ctx.strokeStyle = "rgba(255,200,0,0.9)";
      ctx.beginPath();
      ctx.moveTo(0, h.pin.y);
      ctx.lineTo(canvas.width, h.pin.y);
      ctx.stroke();

      // segmento Ãºtil
      ctx.strokeStyle = "rgba(70,200,255,0.95)";
      ctx.beginPath();
      ctx.moveTo(h.pin.leftEdge, h.pin.y);
      ctx.lineTo(h.pin.rightEdge, h.pin.y);
      ctx.stroke();

      // lÃ­nea vertical en x del pin
      ctx.strokeStyle = "rgba(255,200,0,0.9)";
      ctx.beginPath();
      ctx.moveTo(h.pin.x, 0);
      ctx.lineTo(h.pin.x, canvas.height);
      ctx.stroke();

      // pin (aro blanco + rojo)
      ctx.fillStyle = "white";
      ctx.beginPath();
      ctx.arc(h.pin.x, h.pin.y, 7, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(h.pin.x, h.pin.y, 5, 0, Math.PI*2);
      ctx.fill();
    }
  }

  //////////////////////////////////////////////////////////////
  // PIN EN CANVAS (entradas X:0â€“60, Y:0â€“40)
  //////////////////////////////////////////////////////////////
  function setWidthInfo(i, textWidth="â€”", textSpace="â€”"){
    const w = document.getElementById("widthInfo"+i);
    const s = document.getElementById("spaceInfo"+i);
    if(w) w.textContent = textWidth;
    if(s) s.textContent = textSpace;
  }

  function computePinFromEdges(i){
    const h = holes[i];
    if(h.puntos.length < 3 || !h.cerrado){
      h.pin = null;
      setWidthInfo(i);
      return;
    }

    let v = parseFloat(document.getElementById("vertical"+i).value);
    let hd = parseFloat(document.getElementById("horizontal"+i).value);
    if(isNaN(v) || isNaN(hd)){
      h.pin = null;
      setWidthInfo(i);
      return;
    }

    // clamp
    v = Math.max(0, Math.min(Y_MAX, v));
    hd = Math.max(0, Math.min(X_MAX, hd));

    const side = document.getElementById("lado"+i).value;

    // borde inferior real del polÃ­gono (canvas Y crece hacia abajo)
    const polyBottomY = Math.max(...h.puntos.map(p=>p.y));

    // yLine desde fondo hacia arriba: v (0..Y_MAX)
    const yLine = polyBottomY - (v / Y_MAX) * h.canvas.height;

    // intersecciones con y = yLine
    const intersections = [];
    const pts = [...h.puntos, h.puntos[0]];

    for(let j=0; j<pts.length-1; j++){
      const p1 = pts[j], p2 = pts[j+1];
      if ((yLine >= Math.min(p1.y,p2.y)) && (yLine <= Math.max(p1.y,p2.y)) && (p1.y !== p2.y)) {
        const xInt = p1.x + (yLine - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);
        intersections.push(xInt);
      }
    }

    if(intersections.length < 2){
      h.pin = null;
      setWidthInfo(i);
      return;
    }

    intersections.sort((a,b)=>a-b);
    const leftEdge = intersections[0];
    const rightEdge = intersections[intersections.length-1];
    const segW = rightEdge - leftEdge;
    if(segW <= 1e-6){
      h.pin = null;
      setWidthInfo(i);
      return;
    }

    // horizontal hd (0..X_MAX) medido desde el borde real de ese corte
    const pxPerUnitX = h.canvas.width / X_MAX;
    let x;
    if(side === "left"){
      x = leftEdge + (hd * pxPerUnitX);
    }else{
      x = rightEdge - (hd * pxPerUnitX);
    }
    x = Math.max(leftEdge, Math.min(rightEdge, x));

    // mÃ©tricas ancho disponible en unidades (0..X_MAX)
    const availableWidth = (rightEdge - leftEdge) / pxPerUnitX;
    const leftSpace = (x - leftEdge) / pxPerUnitX;
    const rightSpace = (rightEdge - x) / pxPerUnitX;

    h.pin = {
      x,
      y: yLine,
      leftEdge,
      rightEdge,
      baseY: polyBottomY,
      availableWidth,
      leftSpace,
      rightSpace
    };

    setWidthInfo(
      i,
      `${availableWidth.toFixed(1)}`,
      `${leftSpace.toFixed(1)} / ${rightSpace.toFixed(1)}`
    );
  }

  //////////////////////////////////////////////////////////////
  function cerrarPoligono(i){
    const h = holes[i];
    if(h.puntos.length > 2){
      h.cerrado = true;
      h.baseY = null;
      computePinFromEdges(i);
      redraw(i);
    }
  }

  function limpiar(i){
    const h = holes[i];
    h.puntos = [];
    h.image = null;
    h.imgObj = null;
    h.pin = null;
    h.baseY = null;
    h.cerrado = false;
    setWidthInfo(i);
    redraw(i);
  }

  //////////////////////////////////////////////////////////////
  function importar(i){
    const fileInput = document.getElementById("file"+i);
    fileInput.click();

    fileInput.onchange = e=>{
      const file = e.target.files[0];
      const reader = new FileReader();

      reader.onload = ()=>{
        const img = new Image();
        img.onload = ()=>{
          holes[i].image = reader.result;
          holes[i].imgObj = img;
          redraw(i);
        };
        img.src = reader.result;
      };

      reader.readAsDataURL(file);
    };
  }

  //////////////////////////////////////////////////////////////
  async function detectarGreen(i){
    const h = holes[i];
    if(!h.image){
      alert("Importa imagen primero");
      return;
    }

    const res = await fetch(API + "/detect_green", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({
        image: h.image,
        target_w: h.canvas.width,
        target_h: h.canvas.height
      })
    });

    const data = await res.json();
    if(data.points && data.points.length){
      h.puntos = data.points.map(p=>({x:p.x, y:p.y}));
      h.cerrado = true;
      h.baseY = null;
      computePinFromEdges(i);
      redraw(i);
    }else{
      alert("No se detectÃ³ green");
    }
  }

  //////////////////////////////////////////////////////////////
  // ðŸ”¥ GENERAR PDF: convertimos puntos a sistema X_MAX / Y_MAX
  //////////////////////////////////////////////////////////////
  function canvasPxToData(canvas, p){
    const x = (p.x / canvas.width) * X_MAX;
    const y = ((canvas.height - p.y) / canvas.height) * Y_MAX; // y hacia arriba
    return { x, y };
  }

  async function generarPDF(){
    const club = document.getElementById("club").value || "Club";
    const campo = document.getElementById("course").value || "Campo";
    const fecha = document.getElementById("date").value || "";

    const payload = {
      club,
      campo,
      fecha,
      layout: parseInt(document.getElementById("layoutSelect").value),
      greens: holes.map((h,i)=>({
        points: h.puntos.map(p=>canvasPxToData(h.canvas, p)),
        vertical: Math.max(0, Math.min(Y_MAX, parseFloat(document.getElementById("vertical"+i).value) || 0)),
        horizontal: Math.max(0, Math.min(X_MAX, parseFloat(document.getElementById("horizontal"+i).value) || 0)),
        side: document.getElementById("lado"+i).value
      }))
    };

    const response = await fetch(API + "/generate_pdf", {
      method:"POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(payload)
    });

    if(!response.ok){
      alert("Error generando PDF");
      return;
    }

    const blob = await response.blob();
    const url = URL.createObjectURL(blob);
    const iframe = document.getElementById("preview");
    iframe.src = url;
    iframe.style.display = "block";
  }

  // init
  crearHoyos();

</script>

</body>
</html>
